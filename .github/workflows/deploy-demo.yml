# Deploy to Demo Environment (EC2)
# Triggers automatically on push to main branch
# Uses AWS Session Manager (SSM) to deploy

name: Deploy to Demo

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: deploy-demo
  cancel-in-progress: false

env:
  DEMO_HOST: 18.235.47.142
  APP_USER: usmax
  APP_DIR: /home/usmax/app
  GITHUB_REPO: https://github.com/jschulte/usmax-nda.git

jobs:
  deploy:
    name: Deploy to Demo EC2
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1

      - name: Find EC2 instance
        id: instance
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=ip-address,Values=${{ env.DEMO_HOST }}" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)

          if [ "$INSTANCE_ID" = "None" ] || [ -z "$INSTANCE_ID" ]; then
            echo "‚ùå Could not find EC2 instance with IP ${{ env.DEMO_HOST }}"
            exit 1
          fi

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Found instance: $INSTANCE_ID"

      - name: Deploy via SSM
        run: |
          echo "üöÄ Deploying to ${{ steps.instance.outputs.instance_id }}..."

          # Create deployment script
          cat > /tmp/deploy-commands.sh << 'DEPLOY_SCRIPT'
          set -e
          cd ${{ env.APP_DIR }}
          echo "üì¶ Backing up current app..."
          sudo -u ${{ env.APP_USER }} cp -r ${{ env.APP_DIR }} ${{ env.APP_DIR }}.backup.$(date +%Y%m%d_%H%M%S) || true
          echo "üîß Setting up git repository..."
          if [ ! -d .git ]; then
            sudo -u ${{ env.APP_USER }} git init
            sudo -u ${{ env.APP_USER }} git remote add origin ${{ env.GITHUB_REPO }}
          fi
          sudo -u ${{ env.APP_USER }} git remote set-url origin ${{ env.GITHUB_REPO }} || true
          echo "üì• Pulling latest code from GitHub..."
          sudo -u ${{ env.APP_USER }} git fetch origin
          sudo -u ${{ env.APP_USER }} git reset --hard origin/main
          echo "Current commit: $(git log -1 --oneline)"
          echo "üìö Installing dependencies..."
          sudo -u ${{ env.APP_USER }} pnpm install --no-frozen-lockfile
          echo "üîß Generating Prisma client..."
          sudo -u ${{ env.APP_USER }} pnpm db:generate
          echo "üèóÔ∏è  Building application..."
          sudo -u ${{ env.APP_USER }} pnpm build
          echo "‚ôªÔ∏è  Restarting service..."
          sudo systemctl restart usmax-nda
          echo "‚è≥ Waiting for service to start..."
          sleep 5
          echo "üè• Running health check..."
          if curl -sf http://localhost:3001/api/health > /dev/null; then
            echo "‚úÖ Deployment successful! Service is healthy."
          else
            echo "‚ö†Ô∏è Service may not be responding. Check logs."
            sudo journalctl -u usmax-nda -n 50 --no-pager
            exit 1
          fi
          DEPLOY_SCRIPT

          # Send deployment script as single command (use jq to properly escape for JSON)
          PARAMS=$(jq -n \
            --arg script "$(cat /tmp/deploy-commands.sh)" \
            '{commands: [$script]}')

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.instance.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "$PARAMS" \
            --output text \
            --query "Command.CommandId")

          echo "Command ID: $COMMAND_ID"
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT

          echo "‚è≥ Waiting for deployment to complete..."
          aws ssm wait command-executed \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.instance.outputs.instance_id }}"

          echo ""
          echo "üìã Deployment output:"
          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "${{ steps.instance.outputs.instance_id }}" \
            --query "StandardOutputContent" \
            --output text

      - name: Check deployment status
        if: always()
        run: |
          COMMAND_ID="${{ steps.deploy.outputs.command_id }}"
          INSTANCE_ID="${{ steps.instance.outputs.instance_id }}"

          if [ -n "$COMMAND_ID" ]; then
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text)

            if [ "$STATUS" != "Success" ]; then
              echo "‚ùå Deployment failed with status: $STATUS"
              echo "Error output:"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "StandardErrorContent" \
                --output text
              exit 1
            fi
          fi

  notify:
    name: Notify
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()

    steps:
      - name: Report status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ Demo deployment successful!"
            echo "URL: http://${{ env.DEMO_HOST }}"
            echo "CloudFront: https://d2j310eus7y1g6.cloudfront.net"
          else
            echo "‚ùå Demo deployment failed!"
            exit 1
          fi
        env:
          DEMO_HOST: 18.235.47.142
